<link rel="import" href="bower_components/polymer/polymer-element.html">
<link rel="import" href="three-material.html">
<link rel="import" href="three-line-geometry.html">

<dom-module id="three-lattice">
  <template>
    <template id="geometry" is="dom-repeat" items="{{data}}">
      <three-line-geometry
        id="{{index}}"
        vertices="{{item.vertices}}"
        metadata="{{item.metadata}}"
        contour-by="{{contourBy}}"
        contour-values="{{contourValues}}"
        contour-colors="{{contourColors}}">
      </three-line-geometry>
    </template>
    <three-material id="material" object="{{material}}" color="{{color}}"></three-material>
  </template>
  <script>
    class ThreeLattice extends Polymer.Element {

      static get is() {
        return 'three-lattice';
      }

      static get properties() {
        return {
          color: String,
          data: {type: Array, value: []},
          material: Object,
          geometryCenter: Array,
          geometryRadius: Number,
          contourBy: String,
          contourColors: {
            type: Array,
            value: [
              "#9C27B0",
              "#673AB7",
              "#3F51B5",
              "#2196F3",
              "#00BCD4",
              "#009688",
              "#4CAF50",
              "#8BC34A",
              "#FFEB3B",
              "#FFC107",
              "#FF9800",
              "#FF5722",
              "#F44336"
            ]
          },
          contourValues: {type: Array, computed: '_computeContourValues(contourBy)'},
          object: {
            type: Object,
            computed: '_computeObject(data, material)',
            observer: '_objectChanged',
          },
        }
      }

      static get observers() {
        return [
          '_geometryChanged(geometryRadius, geometryCenter)',
        ]
      }

      connectedCallback() {
        super.connectedCallback();
        this.addEventListener('three-line-geometry-ready', e => this._handleGeometryReady(e.detail));
      }

      _computeObject(data, material) {
        if (!(data && material && data.length > 0)) return;
        return new THREE.Mesh(new THREE.Geometry(), material);
      }

      _computeContourValues(contourBy) {
        const length = this.contourColors.length;
        const values = _.map(this.data, (line) => {return line.metadata[contourBy]});
        const max = _.max(values);
        const min = _.min(values);
        const step = (max - min) / length;
        return _.rangeRight(max, min, -step);
      }

      _geometryChanged(geometryRadius, geometryCenter) {
        if ((geometryRadius && geometryCenter)) this._fireGeometryChanged();
      }

      _handleGeometryReady(geometry) {
        console.log("_handleGeometryReady");
        this.object.geometry.merge(geometry);
        this.object.geometry.elementsNeedUpdate = true;
        this.object.geometry.computeBoundingSphere();
        this.geometryRadius = this.object.geometry.boundingSphere.radius;
        this.geometryCenter = this.object.geometry.boundingSphere.center.toArray();
      }

      _objectChanged(newObject, oldObject) {
        const eventInitDict = {bubbles: true, detail: {object: newObject}};
        this.dispatchEvent(new CustomEvent('lattice-changed', eventInitDict));
      }

      _fireGeometryChanged() {
        const eventInitDict = {
          bubbles: true,
          detail: {geometryRadius: this.geometryRadius, geometryCenter: this.geometryCenter}
        };
        this.dispatchEvent(new CustomEvent('lattice-geometry-changed', eventInitDict));
      }
    }

    customElements.define(ThreeLattice.is, ThreeLattice);
  </script>
</dom-module>