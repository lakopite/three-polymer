<link rel="import" href="bower_components/polymer/polymer-element.html">
<link rel="import" href="three-material.html">
<link rel="import" href="three-line-geometry.html">

<dom-module id="three-lattice">
  <template>
    <template is="dom-repeat" items="{{data}}">
      <three-line-geometry
        id="{{index}}"
        vertices="{{item.vertices}}"
        result="{{item.result}}"
        contour-by="{{contourBy}}"
        contour-values="{{contourValues}}"
        contour-colors="{{contourColors}}"
        object="{{geometry}}">
      </three-line-geometry>
    </template>
    <three-material id="material" object="{{material}}" color="{{color}}"></three-material>
  </template>
  <script>
    class ThreeLattice extends Polymer.Element {

      static get is() {
        return 'three-lattice';
      }

      static get properties() {
        return {
          color: String,
          data: {type: Array, value: []},
          geometry: {type: Object, value: new THREE.Geometry()},
          material: {type: Object},
          geometryCenter: Array,
          geometryRadius: Number,
          contourBy: String,
          contourColors: {
            type: Array,
            value: ["#660066", "#663399", "#9933FF", "#9999FF", "#0066FF", "#0000FF",
              "#00FF00", "#ADFF2F", "#FFFF00", "#FFCC00", "#FF6633", "#FF3300", "#FF0000"]
          },
          contourValues: {type: Array, computed: '_computeContourValues(contourBy)'},
          object: {type: Object, computed: '_computeObject(geometry, material)'},
        }
      }

      connectedCallback() {
        super.connectedCallback();
        this.addEventListener('three-line-geometry-ready', e => this.handleGeometryReady(e));
        const eventInitDict = {bubbles: true, detail: {object: this.object}};
        this.dispatchEvent(new CustomEvent('lattice-connected', eventInitDict));
      }

      _computeObject(geometry, material) {
        if (!(geometry && material)) return;
        return new THREE.Mesh(this.geometry, this.material);
      }

      _computeContourValues(contourBy) {
        const length = this.contourColors.length;
        const values = _.map(this.data, (line) => {return line.result[contourBy]});
        const max = _.max(values);
        const min = _.min(values);
        let step = (max - min) / length;
        return _.rangeRight(max, min, -step);
      }

      handleGeometryReady(e) {
        console.log("handleGeometryReady");
        this.object.geometry.merge(e.detail.object);
        this.object.geometry.elementsNeedUpdate = true;
        this.object.geometry.computeBoundingSphere();
        this.geometryRadius = this.object.geometry.boundingSphere.radius;
        this.geometryCenter = this.object.geometry.boundingSphere.center.toArray();
        const eventInitDict = {
          bubbles: true,
          detail: {geometryRadius: this.geometryRadius, geometryCenter: this.geometryCenter}
        };
        this.dispatchEvent(new CustomEvent('lattice-geometry-changed', eventInitDict));
      }
    }

    customElements.define(ThreeLattice.is, ThreeLattice);
  </script>
</dom-module>