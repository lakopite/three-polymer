<script src="../lodash/lodash.js"></script>
<link rel="import" href="../polymer/polymer-element.html">

<dom-module id="three-line-geometry">
  <script>
    class ThreeLineGeometry extends Polymer.Element {

      static get is() {
        return 'three-line-geometry';
      }

      static get properties() {
        return {
          cameraNormal: {type: Array, value: [0, 1, 0]},
          stroke: {type: Number, value: 1},
          vertices: Array,
          object: {
            type: Object,
            computed: '_computeGeometry(vertices, cameraNormal, stroke)',
            notify: true,
          },
          offsetVector: Array,
          midpoint: {type: Array, computed: '_computeMidpoint(vertices)'},
        }
      }

      _computeGeometry(vertices, cameraNormal, stroke) {
        if (!(vertices && cameraNormal && stroke)) return;
//        console.log("_computeGeometry with midpoint:", this._computeMidpoint(vertices), "stroke:", stroke);
        const toSignificantFigures = (coordinate) => parseFloat(_.round(coordinate, 5).toPrecision(4));

        const centerLineVector = this._scaleVector(_.zipWith(vertices[1], vertices[0], (a, b) => a - b), 1);
        const projectedCenterLineVector = _.zipWith(centerLineVector, cameraNormal, (a, b) => a * (1 - b));

        this.offsetVector = new THREE.Vector3(...projectedCenterLineVector)
          .applyAxisAngle(new THREE.Vector3(...cameraNormal), Math.PI / 2)
          .normalize()
          .toArray()
          .map(toSignificantFigures);

        const scaledOffsetVector = this._scaleVector(this.offsetVector, stroke / 2);

        const v0l = _.zipWith(vertices[0], scaledOffsetVector, (a, b) => a + b).map(toSignificantFigures);
        const v0r = _.zipWith(vertices[0], scaledOffsetVector, (a, b) => a - b).map(toSignificantFigures);
        const v1l = _.zipWith(vertices[1], scaledOffsetVector, (a, b) => a + b).map(toSignificantFigures);
        const v1r = _.zipWith(vertices[1], scaledOffsetVector, (a, b) => a - b).map(toSignificantFigures);

        const geometry = new THREE.Geometry();
        geometry.vertices.push(...[v0l, v0r, v1r, v1l].map(a => new THREE.Vector3(...a)));
        geometry.faces.push(...[[0, 1, 2], [0, 2, 3]].map(a => new THREE.Face3(...a)));

        return geometry;
      }

      _scaleVector(vector, magnitude) {
        const originalMagnitude = Math.pow(vector.map(a => a * a).reduce((a, b) => a + b, 0), 0.5);
        return vector.map(a => a * magnitude / originalMagnitude);
      }

      _computeMidpoint(vertices) {
        return _.zipWith(vertices[0], vertices[1], (c0, c1) => (c0 + c1) / 2);
      }
    }

    customElements.define(ThreeLineGeometry.is, ThreeLineGeometry);
  </script>
</dom-module>