<link rel="import" href="../polymer/polymer.html">
<script src="../threejs/build/three.min.js"></script>
<!--
`three-polymer`
Element for three.js geometry rendering

    <three-polymer
      data='{{modelGeometry}}'
      contour='default'
      background="#000000"
      color="#FFFFFF">
    </three-polymer>

Data can be provided one of two ways:

- Via the `data` attribute, passing in the data directly:
      data='[{"vertices":[{"x": 0, "y": 0, "z": 0},{"x": 10, "y": 0, "z": 0}]},{"vertices":[{"x": 10, "y": 0, "z": 0},{"x": 10, "y": 0, "z": 10}]}]'
- Via the `data` attribute, passing in a valid data object:

      data='{{modelGeometry}}'

Each object within the data attribute must use the following fields:

- `vertices` <b>Mandatory (must have length >= 2)</b> An array that defines the points for the element.
- `faces` <b>Mandatory (if length(vertices) > 2)</b> An array that describes the faces for the corresponding vertices.
- `type` <b>Optional</b> type of element, used if `contour` is set to `type`
- `color` <b>Optional</b> element color, used if `contour` is set to `inherit`
- `{contourable_fields}` <b>Optional</b> The key/values that will be used if `contour` is set to `range`
- Example:
      [
        {
          vertices: [{'x': x1,'y': y1,'z': z1},{'x': x2,'y': y2,'z': z2}...{'x': xn,'y': yn,'z': zn}],
          faces: [[f1,f1,f1],[f2,f2,f2]...[fn,fn,fn]],
          color: '#FF00FF',
          type: 'wall'
          axial: 10, //contourable field
          bm2: 20, //contourable field
          sf2: 30 //contourable field
        },
        ...
        {
          vertices: [{'x': x1,'y': y1,'z': z1},{'x': x2,'y': y2,'z': z2}...{'x': xn,'y': yn,'z': zn}],
          faces: [[f1,f1,f1],[f2,f2,f2]...[fn,fn,fn]],
          color: '#FF00FF',
          type: 'wall'
          axial: 40, //contourable field
          bm2: 50, //contourable field
          sf2: 60 //contourable field
        }
      ]

@demo demo/index.html
-->

<dom-module id="three-polymer">
  <template>
    <style>
      :host {
        display: block;
        height: 100%;
        width: 100%;
      }
      #viz {
        height: 100%;
        width: 100%;
        min-height: 200px;
        min-width: 200px;
      }
    </style>
    <div id="viz">

    </div>
  </template>

  <script>
    Polymer({

      is: 'three-polymer',

      properties: {
        /**
         * Geometry and element information for three-polymer to render
         * See the above guidelines for a valid object
         */
        data: {
          type: Array,
          value: [],
          observer: '_dataChanged'
        },
        /**
         * The color to use for the scene background
         */
        background: {
          type: String,
          value: "#000000"
        },
        /**
         * The default material opacity
         */
        opacity: {
          type: Number,
          value: 0.5
        },
        /**
         * The default material color for non-contoured geometry or for an element who is missing the contourBy key/value
         */
        color: {
          type: String,
          value: "#FFFFFF"
        },
        /**
         * The field to contour the geometry by.  If the field is missing from an element object, the element will be contoured by the default color property
         */
        contourBy: {
          type: String,
          value: ""
        },
        /**
         * Sets the contour type for the dataset. Valid values are:
         * - `default` (contours all geometry w/ the component-wide @color prop),
         * - `range` (uses the contourBy field and contourColors field to contour each element with respect to its specified force value)
         * - `type` (uses the typeMap to contour each element by its respective type attribute)
         * - `inherit` (contours each element by its respective color attribute)
         *
         *An invalid contour value will be set to the `default` mode
         *For non-default modes, if necessary data is missing for an element, it will use the component-wide @color prop
         */
        contour: {
          type: String,
          value: "default"
        },
        /**
         * Color spectrum for contour range
         */
        contourColors: {
      		type: Array,
      		value: ["#660066", "#663399", "#9933FF", "#9999FF", "#0066FF", "#0000FF", "#00FF00", "#ADFF2F", "#FFFF00", "#FFCC00", "#FF6633", "#FF3300", "#FF0000"]
      	},
        /**
         * Object to describe how to contour an element type, used when `contour` is set to `type`
         */
        typeMap: {
          type: Object,
          value: {
            'wall': '#FFFF00',
            'floor': '#0066FF'
          }
        },

        _scene: {
      		type: THREE.Scene,
      	},
        _camera: {
      		type: THREE.PerspectiveCamera,
      	},
      	_renderer: {
      		type: THREE.WebGLRenderer,
      	},
        _mesh: {
      		type: THREE.Mesh,
      	},
        _geo: {
      		type: THREE.Geometry,
      	},
        _initialized: {
          type: Boolean,
          value: false
        }

      },
      listeners: {
        	'iron-resize': '_onIronResize'
  	  },
      _onIronResize: function() {
  	  	if (this._renderer) {
  			   var w = this.$.viz.clientWidth;
  			   var h = this.$.viz.clientHeight;
  			   this._renderer.setSize(w,h);
  			   this._camera.aspect = w / h;
  			   this._camera.updateProjectionMatrix();
  		  }
  	  },
      attached: function() {
        var w = this.$.viz.clientWidth;
        var h = this.$.viz.clientHeight;
        this._scene = new THREE.Scene();
        this._scene.background = new THREE.Color( this._fromHexString(this.background) );
        this._camera = new THREE.PerspectiveCamera( 75, w / h, 0.1, 3000);
        this._renderer = new THREE.WebGLRenderer();
        this._renderer.setSize( w, h );
        Polymer.dom(this.$.viz).appendChild( this._renderer.domElement );

        function render() {
          requestAnimationFrame( render.bind(this) );
          this._camera.updateProjectionMatrix();
          this._renderer.render(this._scene, this._camera );
        }

        render.call(this);

        this.set('_initialized',true);
        this.processGeometry();
      },
      _dataChanged: function(data) {
        this.processGeometry();
      },
      _makeElementConnection: function(v1, v2) {
        //Eventually set these from material dimensions
        var XW = 0.5;
        var YW = 0.5;
        var ZW = 0.5;
        var x1 = v1.x;
        var y1 = v1.y;
        var z1 = v1.z;
        var x2 = v2.x;
        var y2 = v2.y;
        var z2 = v2.z;

        var subGeometry = new THREE.Geometry();

        if (x1 !== x2 && y1 === y2 && z1 === z2) {
      // 		if (this.parameter_payload.material === "Concrete") {
        // 	ZW = parseFloat(this.parameter_payload.beam_depth)/2;
        // 	YW = parseFloat(this.parameter_payload.beam_width)/2;
        // 	XW = parseFloat(this.parameter_payload.column_depth)/2;
        // }
          subGeometry.vertices.push(new THREE.Vector3(x1-XW,y1-YW,z1-ZW));
          subGeometry.vertices.push(new THREE.Vector3(x1-XW,y1+YW,z1-ZW));
          subGeometry.vertices.push(new THREE.Vector3(x1-XW,y1+YW,z1+ZW));
          subGeometry.vertices.push(new THREE.Vector3(x1-XW,y1-YW,z1+ZW));
          subGeometry.vertices.push(new THREE.Vector3(x2+XW,y2-YW,z2-ZW));
          subGeometry.vertices.push(new THREE.Vector3(x2+XW,y2+YW,z2-ZW));
          subGeometry.vertices.push(new THREE.Vector3(x2+XW,y2+YW,z2+ZW));
          subGeometry.vertices.push(new THREE.Vector3(x2+XW,y2-YW,z2+ZW));
        }
        else if (x1 === x2 && y1 !== y2 && z1 === z2) {
          // if (this.parameter_payload.material === "Concrete") {
          // 	ZW = parseFloat(this.parameter_payload.beam_depth)/2;
          // 	XW = parseFloat(this.parameter_payload.beam_width)/2;
          // 	YW = parseFloat(this.parameter_payload.column_width)/2;
          // }
          subGeometry.vertices.push(new THREE.Vector3(x1-XW,y1-YW,z1-ZW));
          subGeometry.vertices.push(new THREE.Vector3(x1-XW,y1-YW,z1+ZW));
          subGeometry.vertices.push(new THREE.Vector3(x1+XW,y1-YW,z1+ZW));
          subGeometry.vertices.push(new THREE.Vector3(x1+XW,y1-YW,z1-ZW));
          subGeometry.vertices.push(new THREE.Vector3(x2-XW,y2+YW,z2-ZW));
          subGeometry.vertices.push(new THREE.Vector3(x2-XW,y2+YW,z2+ZW));
          subGeometry.vertices.push(new THREE.Vector3(x2+XW,y2+YW,z2+ZW));
          subGeometry.vertices.push(new THREE.Vector3(x2+XW,y2+YW,z2-ZW));
        }
        else {
          // if (this.parameter_payload.material === "Concrete") {
          // 	XW = (elementType === "Brace") ? parseFloat(this.parameter_payload.brace_depth)/2 : parseFloat(this.parameter_payload.column_depth)/2;
          // 	YW = (elementType === "Brace") ? parseFloat(this.parameter_payload.brace_width)/2 : parseFloat(this.parameter_payload.column_width)/2;
          // }
          subGeometry.vertices.push(new THREE.Vector3(x1-XW,y1-YW,z1));
          subGeometry.vertices.push(new THREE.Vector3(x1-XW,y1+YW,z1));
          subGeometry.vertices.push(new THREE.Vector3(x1+XW,y1+YW,z1));
          subGeometry.vertices.push(new THREE.Vector3(x1+XW,y1-YW,z1));
          subGeometry.vertices.push(new THREE.Vector3(x2-XW,y2-YW,z2));
          subGeometry.vertices.push(new THREE.Vector3(x2-XW,y2+YW,z2));
          subGeometry.vertices.push(new THREE.Vector3(x2+XW,y2+YW,z2));
          subGeometry.vertices.push(new THREE.Vector3(x2+XW,y2-YW,z2));
        }
        subGeometry.faces.push(new THREE.Face3(0,1,2));
        subGeometry.faces.push(new THREE.Face3(2,3,0));
        subGeometry.faces.push(new THREE.Face3(2,3,6));
        subGeometry.faces.push(new THREE.Face3(3,6,7));
        subGeometry.faces.push(new THREE.Face3(1,2,6));
        subGeometry.faces.push(new THREE.Face3(1,5,6));
        subGeometry.faces.push(new THREE.Face3(0,1,5));
        subGeometry.faces.push(new THREE.Face3(0,4,5));
        subGeometry.faces.push(new THREE.Face3(0,3,7));
        subGeometry.faces.push(new THREE.Face3(0,4,7));
        subGeometry.faces.push(new THREE.Face3(4,5,6));
        subGeometry.faces.push(new THREE.Face3(6,7,4));

        return subGeometry
      },
      processGeometry() {
        if (this._initialized) {
          var material = new THREE.MeshBasicMaterial( {
                color: this._fromHexString(this.color),
                side: THREE.DoubleSide,
  				      vertexColors: true,
  				      transparent: true,
                opacity: this.opacity
              } );
          var geometry = new THREE.Geometry();
          for (var i in this.data) {
            var intermediateMesh = new THREE.Mesh(this._makeElementConnection(this.data[i].vertices[0], this.data[i].vertices[1]), material);
            intermediateMesh.updateMatrix();
            geometry.merge(intermediateMesh.geometry,intermediateMesh.matrix)
          }
          this.set('_geo',geometry);
          this.set('_mesh',new THREE.Mesh(this._geo, material))
          this._scene.children = [this._mesh];
          this._mesh.geometry.computeBoundingSphere();
          this._camera.position.set(0,this._mesh.geometry.boundingSphere.radius * -2.5,0);
  	  		this._camera.up = new THREE.Vector3(0,0,1);
  			  this._camera.lookAt(new THREE.Vector3(0,0,0));
          console.log(this._mesh);
        }
      },
      _fromHexString: function(hexstring) {
        return parseInt(hexstring.replace("#",""),16)
      }

    });
  </script>
</dom-module>
