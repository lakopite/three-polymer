<script src="../lodash/lodash.js"></script>
<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="three-mesh.html">

<dom-module id="three-model">
  <template>
    <template
      id="meshes"
      is="dom-repeat"
      items="{{lines}}"
      as="line"
      initial-count="100"
      target-framerate="1"
      filter="_isWithinCoordinateBoundaries"
      on-rendered-item-count-changed="_handleRenderedItemCountChanged">
      <three-mesh
        id="line-{{index}}"
        on-new-mesh="_handleNewMesh"
        on-remove-mesh="_handleRemoveMesh"
        on-mesh-change="_handleMeshChange"
        vertices="[[line.vertices]]"
        metadata="[[line.metadata]]"
        stroke="[[stroke]]"
        contour-by="[[contourBy]]"
        contour-values="[[contourValues]]"
        contour-colors="[[contourColors]]">
      </three-mesh>
    </template>
  </template>
  <script>
    class ThreeModel extends Polymer.Element {

      static get is() {
        return 'three-model';
      }

      static get properties() {
        return {
          lines: Array,
          data: {type: Array, observer: '_dataChanged'},
          numberOfLines: {type: Number, computed: '_computeNumberOfLines(data)'},
          meshes: {type: Array, value: []},
          object: {
            type: Object,
            observer: '_dispatchNewModel',
          },
          position: Array,
          radius: Number,
          stroke: Number,
          metadataFields: {type: Array, value: [], reflectToAttribute: true, notify: true},
          contourBy: String,
          contourColors: {
            type: Array,
            readOnly: true,
            value: [
              "#9C27B0",
              "#673AB7",
              "#3F51B5",
              "#2196F3",
              "#00BCD4",
              "#009688",
              "#4CAF50",
              "#8BC34A",
              "#FFEB3B",
              "#FFC107",
              "#FF9800",
              "#FF5722",
              "#F44336"
            ]
          },
          contourBounds: {
            type: Object,
            reflectToAttribute: true,
            notify: true,
            computed: '_computeContourBounds(data, contourBy)',
          },
          contourValues: {
            type: Array,
            computed: '_computeContourValues(contourColors, contourBounds)',
          },
          boundaries: {type: Object, reflectToAttribute: true, notify: true},
          geometryFilter: {type: Object, observer: '_geometryFilterChanged', notify: true},
        }
      }

      _geometryFilterChanged() {
        this.$.meshes.render();
      }

      _isWithinCoordinateBoundaries(line) {
        if (!this.geometryFilter) return true;

        const v0 = line.vertices[0];
        const v1 = line.vertices[1];

        const boundingBox = {
          xMin: _.min([v0[0], v1[0]]),
          yMin: _.min([v0[1], v1[1]]),
          zMin: _.min([v0[2], v1[2]]),
          xMax: _.max([v0[0], v1[0]]),
          yMax: _.max([v0[1], v1[1]]),
          zMax: _.max([v0[2], v1[2]])
        };

        return Object.keys(this.geometryFilter)
          .map(key => key.includes('Max')
            ? boundingBox[key] <= this.geometryFilter[key]
            : boundingBox[key] >= this.geometryFilter[key])
          .reduce((a, b) => a && b, true);
      }

      _computeNumberOfLines(data) {
        return data.length;
      }

      _computeContourBounds(data, contourBy) {
        if (!Array.isArray(data) || data.length === 0) return;
        const values = data.map(line => line.metadata[contourBy]);

        const max = values.reduce((p, v) => p > v ? p : v);
        const min = values.reduce((p, v) => p < v ? p : v);

        return {min: min, max: max};
      }

      _computeContourValues(contourColors, contourBounds) {
        if (!(contourColors && contourBounds)) return;
        const length = contourColors.length;
        const step = (contourBounds.max - contourBounds.min) / length;

        const contourValues = [];
        for (let i = contourBounds.max; contourValues.length !== length; i -= step) {
          contourValues.push(_.round(i, 4));
        }

        return contourValues.reverse();
      }

      _handleRenderedItemCountChanged(event) {
        const allLinesAreStamped = event.detail.value === this.numberOfLines;
        if (allLinesAreStamped) {
          if (!this.boundaries) return;
          this.geometryFilter = _.cloneDeep(this.boundaries);
          this.position = [
            (this.boundaries.xMin + this.boundaries.xMax) / 2,
            (this.boundaries.yMin + this.boundaries.yMax) / 2,
            (this.boundaries.zMin + this.boundaries.zMax) / 2
          ];

          this.radius = _.max([
            this.boundaries.xMax - this.position[0],
            this.boundaries.yMax - this.position[1],
            this.boundaries.zMax - this.position[2]
          ]);

          this.stroke = this.radius / 40;

          this._dispatchModelReady();
        }
      }

      _dataChanged(newData) {
//        console.log('_dataChanged');
        this.boundaries = undefined;
        this.geometryFilter = undefined;
        this.lines = [];
        setTimeout(() => {this.lines = newData}, 0);
        const group = new THREE.Group();
        group.name = "mesh";
        this.object = group;
      }

      _updateBoundaries(vertices) {
//        console.log('_updateBoundaries', vertices);
        const v0 = vertices[0];
        const v1 = vertices[1];

        this.boundaries = {
          xMax: _.max([this.boundaries ? this.boundaries.xMax : 0, v0[0], v1[0]]),
          xMin: _.min([this.boundaries ? this.boundaries.xMin : 0, v0[0], v1[0]]),
          yMax: _.max([this.boundaries ? this.boundaries.yMax : 0, v0[1], v1[1]]),
          yMin: _.min([this.boundaries ? this.boundaries.yMin : 0, v0[1], v1[1]]),
          zMax: _.max([this.boundaries ? this.boundaries.zMax : 0, v0[2], v1[2]]),
          zMin: _.min([this.boundaries ? this.boundaries.zMin : 0, v0[2], v1[2]]),
        }
      }

      _handleNewMesh(event) {
//        console.log('_handleNewMesh');
        this._updateBoundaries(event.target.vertices);
        this.object.add(event.target.object);

        const set = new Set(this.metadataFields);
        Object.keys(event.target.metadata).forEach(key => set.add(key));
        this.metadataFields = Array.from(set);

        this._dispatchModelNeedsRender();
      }

      _handleRemoveMesh(event) {
        const mesh = event.target.object;
        this.object.remove(mesh);
        this._dispatchModelNeedsRender();
      }

      _handleMeshChange() {
//        console.log('_handleMeshChange');
        this._dispatchModelNeedsRender();
      }

      _dispatchNewModel() {
        this.dispatchEvent(new CustomEvent('new-model', {bubbles: true}));
      }

      _dispatchModelReady() {
//        console.log('_dispatchModelReady');
        this.dispatchEvent(new CustomEvent('model-ready', {bubbles: true}));
      }

      _dispatchModelNeedsRender() {
        this.dispatchEvent(new CustomEvent('model-needs-render', {bubbles: true}));
      }
    }

    customElements.define(ThreeModel.is, ThreeModel);
  </script>
</dom-module>
